<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/travis/build/Michael-F-Bryan/libsignal-protocol-rs/target/debug/build/libsignal-protocol-sys-8ff6024937295aa9/out/bindings.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>bindings.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../light.css" id="themeStyle"><script src="../../../../../../../../../../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../noscript.css"></noscript><link rel="shortcut icon" href="../../../../../../../../../../../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../../../../../../../../../../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../../../../../../../../../../libsignal_protocol_sys/index.html'><img src='../../../../../../../../../../../../rust-logo.png' alt='logo' width='100'></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../../../../../../../../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../../../../../../../../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../../../../../../../../../../../settings.html"><img src="../../../../../../../../../../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="comment">/* automatically generated by rust-bindgen */</span>

<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_SUCCESS</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">0</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_NOMEM</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">12</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_INVAL</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">22</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_UNKNOWN</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1000</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_DUPLICATE_MESSAGE</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1001</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_INVALID_KEY</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1002</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_INVALID_KEY_ID</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1003</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_INVALID_MAC</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1004</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_INVALID_MESSAGE</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1005</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_INVALID_VERSION</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1006</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_LEGACY_MESSAGE</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1007</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_NO_SESSION</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1008</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_STALE_KEY_EXCHANGE</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1009</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_UNTRUSTED_IDENTITY</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1010</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_VRF_SIG_VERIF_FAILED</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1011</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_INVALID_PROTO_BUF</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1100</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_FP_VERSION_MISMATCH</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1200</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_FP_IDENT_MISMATCH</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">1201</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_ERR_MINIMUM</span> : <span class="ident">i32</span> <span class="op">=</span> <span class="op">-</span><span class="number">9999</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_LOG_ERROR</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">0</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_LOG_WARNING</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">1</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_LOG_NOTICE</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">2</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_LOG_INFO</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">3</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_LOG_DEBUG</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">4</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_CIPHER_AES_CTR_NOPADDING</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">1</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">SG_CIPHER_AES_CBC_PKCS5</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">2</span> ; # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_type_base</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_buffer</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_buffer_list</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_int_list</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_context</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_protocol_store_context</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_protocol_address</span> { <span class="kw">pub</span> <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , <span class="kw">pub</span> <span class="ident">name_len</span> : <span class="ident">usize</span> , <span class="kw">pub</span> <span class="ident">device_id</span> : <span class="ident">i32</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_signal_protocol_address</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_address</span> <span class="op">&gt;</span> ( ) , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_address</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_address</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_address</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_address</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_address</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_address</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name_len</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_address</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name_len</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_address</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">device_id</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_address</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">device_id</span> ) ) ) ; } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_protocol_sender_key_name</span> { <span class="kw">pub</span> <span class="ident">group_id</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , <span class="kw">pub</span> <span class="ident">group_id_len</span> : <span class="ident">usize</span> , <span class="kw">pub</span> <span class="ident">sender</span> : <span class="ident">signal_protocol_address</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_signal_protocol_sender_key_name</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_name</span> <span class="op">&gt;</span> ( ) , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_name</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_name</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">group_id</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_name</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">group_id</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_name</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">group_id_len</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_name</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">group_id_len</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_name</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">sender</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_name</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">sender</span> ) ) ) ; } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ec_public_key</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ec_key_pair</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ratchet_identity_key_pair</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">session_pre_key</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">session_signed_pre_key</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">session_pre_key_bundle</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">session_record</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">session_record_state_node</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">session_state</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">sender_key_record</span> { <span class="ident">_unused</span> : [ <span class="ident">u8</span> ; <span class="number">0</span> ] , } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_create</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">state</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_state</span> , <span class="ident">global_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_serialize</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_record</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_deserialize</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">len</span> : <span class="ident">usize</span> , <span class="ident">global_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_copy</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">other_record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">global_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_has_session_state</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">version</span> : <span class="ident">u32</span> , <span class="ident">alice_base_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ec_public_key</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_get_state</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_state</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_set_state</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">state</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_state</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_get_previous_states_head</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_record</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record_state_node</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_get_previous_states_element</span> ( <span class="ident">node</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_record_state_node</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_state</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_get_previous_states_next</span> ( <span class="ident">node</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_record_state_node</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record_state_node</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Removes the specified node in the previous states list.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param node the node to remove&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return the node immediately following the removed node, or null if at the end of the list&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_get_previous_states_remove</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">node</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record_state_node</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record_state_node</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_is_fresh</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Move the current session_state into the list of \&quot;previous\&quot; session states,&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; and replace the current session_state with a fresh reset instance.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_archive_current_state</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_promote_state</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">promoted_state</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_state</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_get_user_record</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_record</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_set_user_record</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">user_record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_record_destroy</span> ( <span class="ident">type_</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_type_base</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_create</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_pre_key</span> , <span class="ident">id</span> : <span class="ident">u32</span> , <span class="ident">key_pair</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_key_pair</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_serialize</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_deserialize</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_pre_key</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">len</span> : <span class="ident">usize</span> , <span class="ident">global_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_get_id</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key</span> ) <span class="op">-&gt;</span> <span class="ident">u32</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_get_key_pair</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_key_pair</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_destroy</span> ( <span class="ident">type_</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_type_base</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_create</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_signed_pre_key</span> , <span class="ident">id</span> : <span class="ident">u32</span> , <span class="ident">timestamp</span> : <span class="ident">u64</span> , <span class="ident">key_pair</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_key_pair</span> , <span class="ident">signature</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">signature_len</span> : <span class="ident">usize</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_serialize</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_signed_pre_key</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_deserialize</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_signed_pre_key</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">len</span> : <span class="ident">usize</span> , <span class="ident">global_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_get_id</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_signed_pre_key</span> ) <span class="op">-&gt;</span> <span class="ident">u32</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_get_timestamp</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_signed_pre_key</span> ) <span class="op">-&gt;</span> <span class="ident">u64</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_get_key_pair</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_signed_pre_key</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_key_pair</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_get_signature</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_signed_pre_key</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_get_signature_len</span> ( <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_signed_pre_key</span> ) <span class="op">-&gt;</span> <span class="ident">usize</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_signed_pre_key_destroy</span> ( <span class="ident">type_</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_type_base</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_create</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_pre_key_bundle</span> , <span class="ident">registration_id</span> : <span class="ident">u32</span> , <span class="ident">device_id</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> , <span class="ident">pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">pre_key_public</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_public_key</span> , <span class="ident">signed_pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">signed_pre_key_public</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_public_key</span> , <span class="ident">signed_pre_key_signature_data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">signed_pre_key_signature_len</span> : <span class="ident">usize</span> , <span class="ident">identity_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_public_key</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_get_registration_id</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key_bundle</span> ) <span class="op">-&gt;</span> <span class="ident">u32</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_get_device_id</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key_bundle</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_get_pre_key_id</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key_bundle</span> ) <span class="op">-&gt;</span> <span class="ident">u32</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_get_pre_key</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key_bundle</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_public_key</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_get_signed_pre_key_id</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key_bundle</span> ) <span class="op">-&gt;</span> <span class="ident">u32</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_get_signed_pre_key</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key_bundle</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_public_key</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_get_signed_pre_key_signature</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key_bundle</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_get_identity_key</span> ( <span class="ident">bundle</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">session_pre_key_bundle</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_public_key</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">session_pre_key_bundle_destroy</span> ( <span class="ident">type_</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_type_base</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_type_ref</span> ( <span class="ident">instance</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_type_base</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_type_unref</span> ( <span class="ident">instance</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_type_base</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Allocate a new buffer to store data of the provided length.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param len length of the buffer to allocate&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return pointer to the allocated buffer, or 0 on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_alloc</span> ( <span class="ident">len</span> : <span class="ident">usize</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Create a new buffer and copy the provided data into it.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param data pointer to the start of the data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param len length of the data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return pointer to the allocated buffer, or 0 on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_create</span> ( <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">len</span> : <span class="ident">usize</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Create a copy of an existing buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer the existing buffer to copy&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return pointer to the updated buffer, or 0 on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_copy</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_buffer</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Create a copy of an existing buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer the existing buffer to copy&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param n the maximum number of bytes to copy&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return pointer to the updated buffer, or 0 on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_n_copy</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_buffer</span> , <span class="ident">n</span> : <span class="ident">usize</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Append the provided data to an existing buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Note: The underlying buffer is only expanded by an amount sufficient&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; to hold the data being appended. There is no additional reserved space&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; to reduce the need for memory allocations.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer the existing buffer to append to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param data pointer to the start of the data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param len length of the data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return pointer to the updated buffer, or 0 on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_append</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">len</span> : <span class="ident">usize</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Gets the data pointer for the buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This can be used to read and write data stored in the buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer pointer to the buffer instance&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return data pointer&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_data</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Gets the data pointer for the buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This can be used to read and write data stored in the buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer pointer to the buffer instance&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return data pointer&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_const_data</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_buffer</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Gets the length of the data stored within the buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer pointer to the buffer instance&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return data length&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_len</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_buffer</span> ) <span class="op">-&gt;</span> <span class="ident">usize</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Compare two buffers.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer1 first buffer to compare&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer2 second buffer to compare&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 if the two buffers are equal, negative or positive otherwise&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_compare</span> ( <span class="ident">buffer1</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">buffer2</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Free the data buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer pointer to the buffer instance to free&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_free</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Zero and free the data buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function should be used when the buffer contains sensitive&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; data, to make sure the memory is cleared before being freed.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer pointer to the buffer instance to free&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_bzero_free</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Allocate a new buffer list.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return pointer to the allocated buffer, or 0 on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_list_alloc</span> ( ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer_list</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Create a copy of an existing buffer list.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the existing buffer list to copy&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return pointer to the updated buffer, or 0 on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_list_copy</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_buffer_list</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer_list</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Push the provided buffer onto the end of the list.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The list will take ownership of the buffer, and free it when the list is&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; freed.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the buffer list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param buffer the buffer to push&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, or negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_list_push_back</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer_list</span> , <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Gets the size of the buffer list.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the buffer list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return the size of the list&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_list_size</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer_list</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Gets the value of the element at a particular index in the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param index the index within the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return the value&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_list_at</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer_list</span> , <span class="ident">index</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Free the buffer list, including all the buffers added to it.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the buffer list&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_list_free</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer_list</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Free the buffer list, including all the buffers added to it.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function should be used when the buffer list contains sensitive&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; data, to make sure the memory is cleared before being freed.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the buffer list&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_buffer_list_bzero_free</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer_list</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Allocate a new int list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return pointer to the allocated buffer, or 0 on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_int_list_alloc</span> ( ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_int_list</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Push a new value onto the end of the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param value the value to push&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, or negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_int_list_push_back</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_int_list</span> , <span class="ident">value</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Gets the size of the list.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return the size of the list&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_int_list_size</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_int_list</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Gets the value of the element at a particular index in the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param index the index within the list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return the value&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_int_list_at</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_int_list</span> , <span class="ident">index</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Free the int list&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param list the list to free&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_int_list_free</span> ( <span class="ident">list</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_int_list</span> ) ; } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_crypto_provider</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for a secure random number generator.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall fill the provided buffer with random bytes.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param data pointer to the output buffer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param len size of the output buffer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">random_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">data</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for an HMAC-SHA256 implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall initialize an HMAC context with the provided key.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param hmac_context private HMAC context pointer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key pointer to the key&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key_len length of the key&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">hmac_sha256_init_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">hmac_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">key_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for an HMAC-SHA256 implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall update the HMAC context with the provided data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param hmac_context private HMAC context pointer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param data pointer to the data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param data_len length of the data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">hmac_sha256_update_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">hmac_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">data_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for an HMAC-SHA256 implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall finalize an HMAC calculation and populate the output&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; buffer with the result.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param hmac_context private HMAC context pointer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param output buffer to be allocated and populated with the result&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">hmac_sha256_final_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">hmac_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">output</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for an HMAC-SHA256 implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall free the private context allocated in&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; hmac_sha256_init_func.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param hmac_context private HMAC context pointer&quot;</span> ] <span class="kw">pub</span> <span class="ident">hmac_sha256_cleanup_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">hmac_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for a SHA512 message digest implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall initialize a digest context.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param digest_context private digest context pointer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">sha512_digest_init_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">digest_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for a SHA512 message digest implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall update the digest context with the provided data.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param digest_context private digest context pointer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param data pointer to the data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param data_len length of the data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">sha512_digest_update_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">digest_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">data_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for a SHA512 message digest implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall finalize the digest calculation, populate the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; output buffer with the result, and prepare the context for reuse.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param digest_context private digest context pointer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param output buffer to be allocated and populated with the result&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">sha512_digest_final_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">digest_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">output</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for a SHA512 message digest implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function shall free the private context allocated in&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; sha512_digest_init_func.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param digest_context private digest context pointer&quot;</span> ] <span class="kw">pub</span> <span class="ident">sha512_digest_cleanup_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">digest_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for an AES encryption implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param output buffer to be allocated and populated with the ciphertext&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param cipher specific cipher variant to use, either SG_CIPHER_AES_CTR_NOPADDING or SG_CIPHER_AES_CBC_PKCS5&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key the encryption key&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key_len length of the encryption key&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param iv the initialization vector&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param iv_len length of the initialization vector&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param plaintext the plaintext to encrypt&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param plaintext_len length of the plaintext&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">encrypt_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">output</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">cipher</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> , <span class="ident">key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">key_len</span> : <span class="ident">usize</span> , <span class="ident">iv</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">iv_len</span> : <span class="ident">usize</span> , <span class="ident">plaintext</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">plaintext_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Callback for an AES decryption implementation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param output buffer to be allocated and populated with the plaintext&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param cipher specific cipher variant to use, either SG_CIPHER_AES_CTR_NOPADDING or SG_CIPHER_AES_CBC_PKCS5&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key the encryption key&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key_len length of the encryption key&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param iv the initialization vector&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param iv_len length of the initialization vector&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param ciphertext the ciphertext to decrypt&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param ciphertext_len length of the ciphertext&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">decrypt_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">output</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">cipher</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> , <span class="ident">key</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">key_len</span> : <span class="ident">usize</span> , <span class="ident">iv</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">iv_len</span> : <span class="ident">usize</span> , <span class="ident">ciphertext</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> , <span class="ident">ciphertext_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; User data pointer&quot;</span> ] <span class="kw">pub</span> <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_signal_crypto_provider</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) , <span class="number">96usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">random_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">random_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">hmac_sha256_init_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">hmac_sha256_init_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">hmac_sha256_update_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">hmac_sha256_update_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">hmac_sha256_final_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">hmac_sha256_final_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">hmac_sha256_cleanup_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">hmac_sha256_cleanup_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">sha512_digest_init_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">sha512_digest_init_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">sha512_digest_update_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">sha512_digest_update_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">sha512_digest_final_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">56usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">sha512_digest_final_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">sha512_digest_cleanup_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">64usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">sha512_digest_cleanup_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">encrypt_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">72usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">encrypt_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">decrypt_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">80usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">decrypt_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_crypto_provider</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">user_data</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">88usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_crypto_provider</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">user_data</span> ) ) ) ; } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_protocol_session_store</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Returns a copy of the serialized session record corresponding to the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; provided recipient ID + device ID tuple.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record pointer to a freshly allocated buffer containing the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     serialized session record. Unset if no record was found.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     The Signal Protocol library is responsible for freeing this buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param user_record pointer to a freshly allocated buffer containing&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     application specific data stored alongside the serialized session&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     record. If no such data exists, then this pointer may be left unset.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     The Signal Protocol library is responsible for freeing this buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param address the address of the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 1 if the session was loaded, 0 if the session was not found, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">load_session_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">user_record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Returns all known devices with active sessions for a recipient&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param pointer to an array that will be allocated and populated with the result&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param name the name of the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param name_len the length of the name&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return size of the sessions array, or negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">get_sub_device_sessions_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">sessions</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_int_list</span> , <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , <span class="ident">name_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Commit to storage the session record for a given&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; recipient ID + device ID tuple.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param address the address of the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record pointer to a buffer containing the serialized session&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     record for the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record_len length of the serialized session record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param user_record pointer to a buffer containing application specific&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     data to be stored alongside the serialized session record for the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     remote client. If no such data exists, then this pointer will be null.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param user_record_len length of the application specific data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">store_session_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">record_len</span> : <span class="ident">usize</span> , <span class="ident">user_record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">user_record_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Determine whether there is a committed session record for a&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; recipient ID + device ID tuple.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param address the address of the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 1 if a session record exists, 0 otherwise.&quot;</span> ] <span class="kw">pub</span> <span class="ident">contains_session_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Remove a session record for a recipient ID + device ID tuple.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param address the address of the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 1 if a session was deleted, 0 if a session was not deleted, negative on error&quot;</span> ] <span class="kw">pub</span> <span class="ident">delete_session_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Remove the session records corresponding to all devices of a recipient ID.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param name the name of the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param name_len the length of the name&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return the number of deleted sessions on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">delete_all_sessions_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , <span class="ident">name_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function called to perform cleanup when the data store context is being&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; destroyed.&quot;</span> ] <span class="kw">pub</span> <span class="ident">destroy_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; User data pointer&quot;</span> ] <span class="kw">pub</span> <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_signal_protocol_session_store</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) , <span class="number">64usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">load_session_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">load_session_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">get_sub_device_sessions_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">get_sub_device_sessions_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">store_session_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">store_session_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">contains_session_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">contains_session_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">delete_session_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">delete_session_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">delete_all_sessions_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">delete_all_sessions_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">destroy_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">destroy_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_session_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">user_data</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">56usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_session_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">user_data</span> ) ) ) ; } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_protocol_pre_key_store</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Load a local serialized PreKey record.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record pointer to a newly allocated buffer containing the record,&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     if found. Unset if no record was found.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     The Signal Protocol library is responsible for freeing this buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param pre_key_id the ID of the local serialized PreKey record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @retval SG_SUCCESS if the key was found&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @retval SG_ERR_INVALID_KEY_ID if the key could not be found&quot;</span> ] <span class="kw">pub</span> <span class="ident">load_pre_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Store a local serialized PreKey record.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param pre_key_id the ID of the PreKey record to store.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record pointer to a buffer containing the serialized record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record_len length of the serialized record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">store_pre_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">record_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Determine whether there is a committed PreKey record matching the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; provided ID.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param pre_key_id A PreKey record ID.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 1 if the store has a record for the PreKey ID, 0 otherwise&quot;</span> ] <span class="kw">pub</span> <span class="ident">contains_pre_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Delete a PreKey record from local storage.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param pre_key_id The ID of the PreKey record to remove.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">remove_pre_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function called to perform cleanup when the data store context is being&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; destroyed.&quot;</span> ] <span class="kw">pub</span> <span class="ident">destroy_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; User data pointer&quot;</span> ] <span class="kw">pub</span> <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_signal_protocol_pre_key_store</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_pre_key_store</span> <span class="op">&gt;</span> ( ) , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_pre_key_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_pre_key_store</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_pre_key_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">load_pre_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">load_pre_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">store_pre_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">store_pre_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">contains_pre_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">contains_pre_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">remove_pre_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">remove_pre_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">destroy_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">destroy_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">user_data</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">user_data</span> ) ) ) ; } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_protocol_signed_pre_key_store</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Load a local serialized signed PreKey record.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record pointer to a newly allocated buffer containing the record,&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     if found. Unset if no record was found.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     The Signal Protocol library is responsible for freeing this buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param signed_pre_key_id the ID of the local signed PreKey record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @retval SG_SUCCESS if the key was found&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @retval SG_ERR_INVALID_KEY_ID if the key could not be found&quot;</span> ] <span class="kw">pub</span> <span class="ident">load_signed_pre_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">signed_pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Store a local serialized signed PreKey record.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param signed_pre_key_id the ID of the signed PreKey record to store&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record pointer to a buffer containing the serialized record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record_len length of the serialized record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">store_signed_pre_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">signed_pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">record_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Determine whether there is a committed signed PreKey record matching&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; the provided ID.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param signed_pre_key_id A signed PreKey record ID.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 1 if the store has a record for the signed PreKey ID, 0 otherwise&quot;</span> ] <span class="kw">pub</span> <span class="ident">contains_signed_pre_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">signed_pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Delete a SignedPreKeyRecord from local storage.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param signed_pre_key_id The ID of the signed PreKey record to remove.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">remove_signed_pre_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">signed_pre_key_id</span> : <span class="ident">u32</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function called to perform cleanup when the data store context is being&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; destroyed.&quot;</span> ] <span class="kw">pub</span> <span class="ident">destroy_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; User data pointer&quot;</span> ] <span class="kw">pub</span> <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_signal_protocol_signed_pre_key_store</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_signed_pre_key_store</span> <span class="op">&gt;</span> ( ) , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_signed_pre_key_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_signed_pre_key_store</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_signed_pre_key_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_signed_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">load_signed_pre_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_signed_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">load_signed_pre_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_signed_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">store_signed_pre_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_signed_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">store_signed_pre_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_signed_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">contains_signed_pre_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_signed_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">contains_signed_pre_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_signed_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">remove_signed_pre_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_signed_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">remove_signed_pre_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_signed_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">destroy_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_signed_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">destroy_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_signed_pre_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">user_data</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_signed_pre_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">user_data</span> ) ) ) ; } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_protocol_identity_key_store</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Get the local client&#39;s identity key pair.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param public_data pointer to a newly allocated buffer containing the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     public key, if found. Unset if no record was found.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     The Signal Protocol library is responsible for freeing this buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param private_data pointer to a newly allocated buffer containing the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     private key, if found. Unset if no record was found.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     The Signal Protocol library is responsible for freeing this buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">get_identity_key_pair</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">public_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">private_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Return the local client&#39;s registration ID.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Clients should maintain a registration ID, a random number&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; between 1 and 16380 that&#39;s generated once at install time.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param registration_id pointer to be set to the local client&#39;s&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     registration ID, if it was successfully retrieved.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">get_local_registration_id</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">registration_id</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u32</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Save a remote client&#39;s identity key&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; &lt;p&gt;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Store a remote client&#39;s identity key as trusted.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The value of key_data may be null. In this case remove the key data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; from the identity store, but retain any metadata that may be kept&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; alongside it.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param address the address of the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key_data Pointer to the remote client&#39;s identity key, may be null&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key_len Length of the remote client&#39;s identity key&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">save_identity</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">key_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">key_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Verify a remote client&#39;s identity key.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Determine whether a remote client&#39;s identity is trusted.  Convention is&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; that the TextSecure protocol is &#39;trust on first use.&#39;  This means that&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; an identity key is considered &#39;trusted&#39; if there is no entry for the recipient&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; in the local store, or if it matches the saved key for a recipient in the local&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; store.  Only if it mismatches an entry in the local store is it considered&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; &#39;untrusted.&#39;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param address the address of the remote client&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param identityKey The identity key to verify.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key_data Pointer to the identity key to verify&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param key_len Length of the identity key to verify&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 1 if trusted, 0 if untrusted, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">is_trusted_identity</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">key_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">key_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function called to perform cleanup when the data store context is being&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; destroyed.&quot;</span> ] <span class="kw">pub</span> <span class="ident">destroy_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; User data pointer&quot;</span> ] <span class="kw">pub</span> <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_signal_protocol_identity_key_store</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_identity_key_store</span> <span class="op">&gt;</span> ( ) , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_identity_key_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_identity_key_store</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_identity_key_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_identity_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">get_identity_key_pair</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_identity_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">get_identity_key_pair</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_identity_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">get_local_registration_id</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_identity_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">get_local_registration_id</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_identity_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">save_identity</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_identity_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">save_identity</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_identity_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">is_trusted_identity</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_identity_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">is_trusted_identity</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_identity_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">destroy_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_identity_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">destroy_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_identity_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">user_data</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_identity_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">user_data</span> ) ) ) ; } # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">signal_protocol_sender_key_store</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Store a serialized sender key record for a given&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; (groupId + senderId + deviceId) tuple.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param sender_key_name the (groupId + senderId + deviceId) tuple&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record pointer to a buffer containing the serialized record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record_len length of the serialized record&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param user_record pointer to a buffer containing application specific&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     data to be stored alongside the serialized record. If no such&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     data exists, then this pointer will be null.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param user_record_len length of the application specific data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">store_sender_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">sender_key_name</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_sender_key_name</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">record_len</span> : <span class="ident">usize</span> , <span class="ident">user_record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , <span class="ident">user_record_len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Returns a copy of the sender key record corresponding to the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; (groupId + senderId + deviceId) tuple.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param record pointer to a newly allocated buffer containing the record,&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     if found. Unset if no record was found.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     The Signal Protocol library is responsible for freeing this buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param user_record pointer to a newly allocated buffer containing&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     application-specific data stored alongside the record. If no such&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     data exists, then this pointer may be left unset.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     The Signal Protocol library is responsible for freeing this buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param sender_key_name the (groupId + senderId + deviceId) tuple&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 1 if the record was loaded, 0 if the record was not found, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="ident">load_sender_key</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">user_record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_buffer</span> , <span class="ident">sender_key_name</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_sender_key_name</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function called to perform cleanup when the data store context is being&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; destroyed.&quot;</span> ] <span class="kw">pub</span> <span class="ident">destroy_func</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; User data pointer&quot;</span> ] <span class="kw">pub</span> <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_signal_protocol_sender_key_store</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_store</span> <span class="op">&gt;</span> ( ) , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_store</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_store</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">store_sender_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">store_sender_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">load_sender_key</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">load_sender_key</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">destroy_func</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">destroy_func</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">signal_protocol_sender_key_store</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">user_data</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">signal_protocol_sender_key_store</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">user_data</span> ) ) ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Create a new instance of the global library context.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_context_create</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Set the crypto provider to be used by the Signal Protocol library.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param crypto_provider Populated structure of crypto provider function&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     pointers. The contents of this structure are copied, so the caller&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;     does not need to maintain its instance.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_context_set_crypto_provider</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> , <span class="ident">crypto_provider</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_crypto_provider</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Set the locking functions to be used by the Signal Protocol library for&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; synchronization.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Note: These functions must allow recursive locking (e.g. PTHREAD_MUTEX_RECURSIVE)&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param lock function to lock a mutex&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @param unlock function to unlock a mutex&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_context_set_locking_functions</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> , <span class="ident">lock</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , <span class="ident">unlock</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Set the log function to be used by the Signal Protocol library for logging.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; @return 0 on success, negative on failure&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_context_set_log_function</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> , <span class="ident">log</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">level</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> , <span class="ident">message</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , <span class="ident">len</span> : <span class="ident">usize</span> , <span class="ident">user_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_context_destroy</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Create a new instance of the Signal Protocol data store interface.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_store_context_create</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">global_context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_context</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_store_context_set_session_store</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">store</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_session_store</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_store_context_set_pre_key_store</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">store</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_pre_key_store</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_store_context_set_signed_pre_key_store</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">store</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_signed_pre_key_store</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_store_context_set_identity_key_store</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">store</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_identity_key_store</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_store_context_set_sender_key_store</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">store</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_sender_key_store</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_store_context_destroy</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_session_load_session</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> , <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_session_get_sub_device_sessions</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">sessions</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_int_list</span> , <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , <span class="ident">name_len</span> : <span class="ident">usize</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_session_store_session</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_record</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_session_contains_session</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_session_delete_session</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_session_delete_all_sessions</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , <span class="ident">name_len</span> : <span class="ident">usize</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_pre_key_load_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_pre_key</span> , <span class="ident">pre_key_id</span> : <span class="ident">u32</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_pre_key_store_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_pre_key</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_pre_key_contains_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">pre_key_id</span> : <span class="ident">u32</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_pre_key_remove_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">pre_key_id</span> : <span class="ident">u32</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_signed_pre_key_load_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_signed_pre_key</span> , <span class="ident">signed_pre_key_id</span> : <span class="ident">u32</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_signed_pre_key_store_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">pre_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">session_signed_pre_key</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_signed_pre_key_contains_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">signed_pre_key_id</span> : <span class="ident">u32</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_signed_pre_key_remove_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">signed_pre_key_id</span> : <span class="ident">u32</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_identity_get_key_pair</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">key_pair</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ratchet_identity_key_pair</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_identity_get_local_registration_id</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">registration_id</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u32</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_identity_save_identity</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">identity_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_public_key</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_identity_is_trusted_identity</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">address</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_address</span> , <span class="ident">identity_key</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ec_public_key</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_sender_key_store_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">sender_key_name</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_sender_key_name</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">sender_key_record</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">signal_protocol_sender_key_load_key</span> ( <span class="ident">context</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">signal_protocol_store_context</span> , <span class="ident">record</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">sender_key_record</span> , <span class="ident">sender_key_name</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">signal_protocol_sender_key_name</span> ) <span class="op">-&gt;</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; A well-formed message must have exactly one of this field.&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCLabel_PROTOBUF_C_LABEL_REQUIRED</span> : <span class="ident">ProtobufCLabel</span> <span class="op">=</span> <span class="number">0</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; A well-formed message can have zero or one of this field (but not&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; more than one).&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCLabel_PROTOBUF_C_LABEL_OPTIONAL</span> : <span class="ident">ProtobufCLabel</span> <span class="op">=</span> <span class="number">1</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This field can be repeated any number of times (including zero) in a&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; well-formed message. The order of the repeated values will be&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; preserved.&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCLabel_PROTOBUF_C_LABEL_REPEATED</span> : <span class="ident">ProtobufCLabel</span> <span class="op">=</span> <span class="number">2</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Message field rules.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\see [Defining A Message Type] in the Protocol Buffers documentation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; [Defining A Message Type]:&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      https://developers.google.com/protocol-buffers/docs/proto#simple&quot;</span> ] <span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ProtobufCLabel</span> <span class="op">=</span> <span class="ident">u32</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; int32&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_INT32</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">0</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; signed int32&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_SINT32</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">1</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; signed int32 (4 bytes)&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_SFIXED32</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">2</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; int64&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_INT64</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">3</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; signed int64&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_SINT64</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">4</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; signed int64 (8 bytes)&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_SFIXED64</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">5</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; unsigned int32&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_UINT32</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">6</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; unsigned int32 (4 bytes)&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_FIXED32</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">7</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; unsigned int64&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_UINT64</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">8</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; unsigned int64 (8 bytes)&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_FIXED64</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">9</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; float&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_FLOAT</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">10</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; double&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_DOUBLE</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">11</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; boolean&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_BOOL</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">12</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; enumerated type&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_ENUM</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">13</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; UTF-8 or ASCII string&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_STRING</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">14</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; arbitrary byte sequence&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_BYTES</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">15</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&lt; nested message&quot;</span> ] <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCType_PROTOBUF_C_TYPE_MESSAGE</span> : <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="number">16</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Field value types.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\see [Scalar Value Types] in the Protocol Buffers documentation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; [Scalar Value Types]:&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      https://developers.google.com/protocol-buffers/docs/proto#scalar&quot;</span> ] <span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ProtobufCType</span> <span class="op">=</span> <span class="ident">u32</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCWireType_PROTOBUF_C_WIRE_TYPE_VARINT</span> : <span class="ident">ProtobufCWireType</span> <span class="op">=</span> <span class="number">0</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCWireType_PROTOBUF_C_WIRE_TYPE_64BIT</span> : <span class="ident">ProtobufCWireType</span> <span class="op">=</span> <span class="number">1</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCWireType_PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED</span> : <span class="ident">ProtobufCWireType</span> <span class="op">=</span> <span class="number">2</span> ; <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">ProtobufCWireType_PROTOBUF_C_WIRE_TYPE_32BIT</span> : <span class="ident">ProtobufCWireType</span> <span class="op">=</span> <span class="number">5</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Field wire types.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\see [Message Structure] in the Protocol Buffers documentation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; [Message Structure]:&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      https://developers.google.com/protocol-buffers/docs/encoding#structure&quot;</span> ] <span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ProtobufCWireType</span> <span class="op">=</span> <span class="ident">u32</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Boolean type.&quot;</span> ] <span class="kw">pub</span> <span class="kw">type</span> <span class="ident">protobuf_c_boolean</span> <span class="op">=</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ; <span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ProtobufCClosure</span> <span class="op">=</span> :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">arg1</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessage</span> , <span class="ident">closure_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> ; <span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ProtobufCMessageInit</span> <span class="op">=</span> :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">arg1</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCMessage</span> ) <span class="op">&gt;</span> ; <span class="kw">pub</span> <span class="kw">type</span> <span class="ident">ProtobufCServiceDestroy</span> <span class="op">=</span> :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">arg1</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCService</span> ) <span class="op">&gt;</span> ; # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Structure for defining a custom memory allocator.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCAllocator</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function to allocate memory.&quot;</span> ] <span class="kw">pub</span> <span class="ident">alloc</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">allocator_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">size</span> : <span class="ident">usize</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function to free memory.&quot;</span> ] <span class="kw">pub</span> <span class="ident">free</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">allocator_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , <span class="ident">pointer</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Opaque pointer passed to `alloc` and `free` functions.&quot;</span> ] <span class="kw">pub</span> <span class="ident">allocator_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCAllocator</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCAllocator</span> <span class="op">&gt;</span> ( ) , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCAllocator</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCAllocator</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCAllocator</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCAllocator</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">alloc</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCAllocator</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">alloc</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCAllocator</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">free</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCAllocator</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">free</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCAllocator</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">allocator_data</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCAllocator</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">allocator_data</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Structure for defining a virtual append-only buffer. Used by&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; protobuf_c_message_pack_to_buffer() to abstract the consumption of serialized&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; bytes.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; `ProtobufCBuffer` \&quot;subclasses\&quot; may be defined on the stack. For example, to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; write to a `FILE` object:&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;~~~{.c}&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;typedef struct {&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;ProtobufCBuffer base;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;FILE *fp;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;} BufferAppendToFile;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;static void&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;my_buffer_file_append(ProtobufCBuffer *buffer,&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;size_t len,&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;const uint8_t *data)&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;{&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;BufferAppendToFile *file_buf = (BufferAppendToFile *) buffer;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;fwrite(data, len, 1, file_buf-&gt;fp); // XXX: No error handling!&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;}&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;~~~&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; To use this new type of ProtobufCBuffer, it could be called as follows:&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;~~~{.c}&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;...&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;BufferAppendToFile tmp = {0};&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;tmp.base.append = my_buffer_file_append;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;tmp.fp = fp;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;protobuf_c_message_pack_to_buffer(&amp;message, &amp;tmp);&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;...&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;~~~&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCBuffer</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Append function. Consumes the `len` bytes stored at `data`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">append</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCBuffer</span> , <span class="ident">len</span> : <span class="ident">usize</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> ) <span class="op">&gt;</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCBuffer</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCBuffer</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCBuffer</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCBuffer</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCBuffer</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCBuffer</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">append</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCBuffer</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">append</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Describes an enumeration as a whole, with all of its values.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCEnumDescriptor</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Magic value checked to ensure that the API is used correctly.&quot;</span> ] <span class="kw">pub</span> <span class="ident">magic</span> : <span class="ident">u32</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The qualified name (e.g., \&quot;namespace.Type\&quot;).&quot;</span> ] <span class="kw">pub</span> <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The unqualified name as given in the .proto file (e.g., \&quot;Type\&quot;).&quot;</span> ] <span class="kw">pub</span> <span class="ident">short_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Identifier used in generated C code.&quot;</span> ] <span class="kw">pub</span> <span class="ident">c_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The dot-separated namespace.&quot;</span> ] <span class="kw">pub</span> <span class="ident">package_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Number elements in `values`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">n_values</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Array of distinct values, sorted by numeric value.&quot;</span> ] <span class="kw">pub</span> <span class="ident">values</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCEnumValue</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Number of elements in `values_by_name`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">n_value_names</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Array of named values, including aliases, sorted by name.&quot;</span> ] <span class="kw">pub</span> <span class="ident">values_by_name</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCEnumValueIndex</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Number of elements in `value_ranges`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">n_value_ranges</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Value ranges, for faster lookups by numeric value.&quot;</span> ] <span class="kw">pub</span> <span class="ident">value_ranges</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCIntRange</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved1</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved2</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved3</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved4</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCEnumDescriptor</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">120usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">magic</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">magic</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">short_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">short_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">c_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">c_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">package_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">package_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">n_values</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">n_values</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">values</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">values</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">n_value_names</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">56usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">n_value_names</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">values_by_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">64usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">values_by_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">n_value_ranges</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">72usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">n_value_ranges</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">value_ranges</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">80usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">value_ranges</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved1</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">88usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved1</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved2</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">96usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved2</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved3</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">104usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved3</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved4</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">112usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved4</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Represents a single value of an enumeration.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCEnumValue</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The string identifying this value in the .proto file.&quot;</span> ] <span class="kw">pub</span> <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The string identifying this value in generated C code.&quot;</span> ] <span class="kw">pub</span> <span class="ident">c_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The numeric value assigned in the .proto file.&quot;</span> ] <span class="kw">pub</span> <span class="ident">value</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCEnumValue</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValue</span> <span class="op">&gt;</span> ( ) , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValue</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValue</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValue</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValue</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValue</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValue</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">c_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValue</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">c_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValue</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">value</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValue</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">value</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Used by `ProtobufCEnumDescriptor` to look up enum values.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCEnumValueIndex</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Name of the enum value.&quot;</span> ] <span class="kw">pub</span> <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Index into values[] array.&quot;</span> ] <span class="kw">pub</span> <span class="ident">index</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCEnumValueIndex</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValueIndex</span> <span class="op">&gt;</span> ( ) , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValueIndex</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValueIndex</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValueIndex</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValueIndex</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValueIndex</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCEnumValueIndex</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">index</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCEnumValueIndex</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">index</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Describes a single field in a message.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCFieldDescriptor</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Name of the field as given in the .proto file.&quot;</span> ] <span class="kw">pub</span> <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Tag value of the field as given in the .proto file.&quot;</span> ] <span class="kw">pub</span> <span class="ident">id</span> : <span class="ident">u32</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">label</span> : <span class="ident">ProtobufCLabel</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The type of the field.&quot;</span> ] <span class="kw">pub</span> <span class="ident">type_</span> : <span class="ident">ProtobufCType</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The offset in bytes of the message&#39;s C structure&#39;s quantifier field&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; (the `has_MEMBER` field for optional members or the `n_MEMBER` field&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; for repeated members or the case enum for oneofs).&quot;</span> ] <span class="kw">pub</span> <span class="ident">quantifier_offset</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The offset in bytes into the message&#39;s C structure for the member&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; itself.&quot;</span> ] <span class="kw">pub</span> <span class="ident">offset</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; A type-specific descriptor.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; corresponding `ProtobufCEnumDescriptor`.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; the corresponding `ProtobufCMessageDescriptor`.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Otherwise this field is NULL.&quot;</span> ] <span class="kw">pub</span> <span class="ident">descriptor</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The default value for this field, if defined. May be NULL.&quot;</span> ] <span class="kw">pub</span> <span class="ident">default_value</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; A flag word. Zero or more of the bits defined in the&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; `ProtobufCFieldFlag` enum may be set.&quot;</span> ] <span class="kw">pub</span> <span class="ident">flags</span> : <span class="ident">u32</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved_flags</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved2</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved3</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCFieldDescriptor</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">72usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">id</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">id</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">label</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">12usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">label</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">type_</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">type_</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">quantifier_offset</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">20usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">quantifier_offset</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">offset</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">offset</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">descriptor</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">descriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">default_value</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">default_value</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">flags</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">flags</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved_flags</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">52usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved_flags</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved2</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">56usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved2</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCFieldDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved3</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">64usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCFieldDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved3</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Helper structure for optimizing int =&gt; index lookups in the case&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; where the keys are mostly consecutive values, as they presumably are for&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; enums and fields.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The data structures requires that the values in the original array are&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; sorted.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCIntRange</span> { <span class="kw">pub</span> <span class="ident">start_value</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> , <span class="kw">pub</span> <span class="ident">orig_index</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCIntRange</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCIntRange</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCIntRange</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCIntRange</span> <span class="op">&gt;</span> ( ) , <span class="number">4usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCIntRange</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCIntRange</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">start_value</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCIntRange</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">start_value</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCIntRange</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">orig_index</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">4usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCIntRange</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">orig_index</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; An instance of a message.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; `ProtobufCMessage` is a light-weight \&quot;base class\&quot; for all messages.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; In particular, `ProtobufCMessage` doesn&#39;t have any allocation policy&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; associated with it. That&#39;s because it&#39;s common to create `ProtobufCMessage`&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; objects on the stack. In fact, that&#39;s what we recommend for sending messages.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; If the object is allocated from the stack, you can&#39;t really have a memory&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; leak.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This means that calls to functions like protobuf_c_message_unpack() which&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; return a `ProtobufCMessage` must be paired with a call to a free function,&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; like protobuf_c_message_free_unpacked().&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCMessage</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The descriptor for this message type.&quot;</span> ] <span class="kw">pub</span> <span class="ident">descriptor</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessageDescriptor</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The number of elements in `unknown_fields`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">n_unknown_fields</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The fields that weren&#39;t recognized by the parser.&quot;</span> ] <span class="kw">pub</span> <span class="ident">unknown_fields</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCMessageUnknownField</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCMessage</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessage</span> <span class="op">&gt;</span> ( ) , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessage</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessage</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessage</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessage</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">descriptor</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessage</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">descriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessage</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">n_unknown_fields</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessage</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">n_unknown_fields</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessage</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">unknown_fields</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessage</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">unknown_fields</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Describes a message.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCMessageDescriptor</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Magic value checked to ensure that the API is used correctly.&quot;</span> ] <span class="kw">pub</span> <span class="ident">magic</span> : <span class="ident">u32</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The qualified name (e.g., \&quot;namespace.Type\&quot;).&quot;</span> ] <span class="kw">pub</span> <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The unqualified name as given in the .proto file (e.g., \&quot;Type\&quot;).&quot;</span> ] <span class="kw">pub</span> <span class="ident">short_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Identifier used in generated C code.&quot;</span> ] <span class="kw">pub</span> <span class="ident">c_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The dot-separated namespace.&quot;</span> ] <span class="kw">pub</span> <span class="ident">package_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Size in bytes of the C structure representing an instance of this&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; type of message.&quot;</span> ] <span class="kw">pub</span> <span class="ident">sizeof_message</span> : <span class="ident">usize</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Number of elements in `fields`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">n_fields</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Field descriptors, sorted by tag number.&quot;</span> ] <span class="kw">pub</span> <span class="ident">fields</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCFieldDescriptor</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Used for looking up fields by name.&quot;</span> ] <span class="kw">pub</span> <span class="ident">fields_sorted_by_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Number of elements in `field_ranges`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">n_field_ranges</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Used for looking up fields by id.&quot;</span> ] <span class="kw">pub</span> <span class="ident">field_ranges</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCIntRange</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Message initialisation function.&quot;</span> ] <span class="kw">pub</span> <span class="ident">message_init</span> : <span class="ident">ProtobufCMessageInit</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved1</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved2</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Reserved for future use.&quot;</span> ] <span class="kw">pub</span> <span class="ident">reserved3</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCMessageDescriptor</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">120usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">magic</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">magic</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">short_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">short_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">c_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">c_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">package_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">package_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">sizeof_message</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">sizeof_message</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">n_fields</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">n_fields</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">fields</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">56usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">fields</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">fields_sorted_by_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">64usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">fields_sorted_by_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">n_field_ranges</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">72usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">n_field_ranges</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">field_ranges</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">80usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">field_ranges</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">message_init</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">88usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">message_init</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved1</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">96usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved1</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved2</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">104usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved2</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">reserved3</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">112usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">reserved3</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; An unknown message field.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCMessageUnknownField</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The tag number.&quot;</span> ] <span class="kw">pub</span> <span class="ident">tag</span> : <span class="ident">u32</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The wire type of the field.&quot;</span> ] <span class="kw">pub</span> <span class="ident">wire_type</span> : <span class="ident">ProtobufCWireType</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Number of bytes in `data`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">len</span> : <span class="ident">usize</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Field data.&quot;</span> ] <span class="kw">pub</span> <span class="ident">data</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCMessageUnknownField</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageUnknownField</span> <span class="op">&gt;</span> ( ) , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageUnknownField</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageUnknownField</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageUnknownField</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageUnknownField</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">tag</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageUnknownField</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">tag</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageUnknownField</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">wire_type</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">4usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageUnknownField</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">wire_type</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageUnknownField</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">len</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageUnknownField</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">len</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMessageUnknownField</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">data</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMessageUnknownField</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">data</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Method descriptor.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCMethodDescriptor</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Method name.&quot;</span> ] <span class="kw">pub</span> <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Input message descriptor.&quot;</span> ] <span class="kw">pub</span> <span class="ident">input</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessageDescriptor</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Output message descriptor.&quot;</span> ] <span class="kw">pub</span> <span class="ident">output</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessageDescriptor</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCMethodDescriptor</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMethodDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMethodDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMethodDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMethodDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMethodDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMethodDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMethodDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">input</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMethodDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">input</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCMethodDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">output</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCMethodDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">output</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Service.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCService</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Service descriptor.&quot;</span> ] <span class="kw">pub</span> <span class="ident">descriptor</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCServiceDescriptor</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function to invoke the service.&quot;</span> ] <span class="kw">pub</span> <span class="ident">invoke</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">service</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCService</span> , <span class="ident">method_index</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , <span class="ident">input</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessage</span> , <span class="ident">closure</span> : <span class="ident">ProtobufCClosure</span> , <span class="ident">closure_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) <span class="op">&gt;</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Function to destroy the service.&quot;</span> ] <span class="kw">pub</span> <span class="ident">destroy</span> : :: <span class="ident">std</span> :: <span class="ident">option</span> :: <span class="prelude-ty">Option</span> <span class="op">&lt;</span> <span class="kw">unsafe</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> ( <span class="ident">service</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCService</span> ) <span class="op">&gt;</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCService</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCService</span> <span class="op">&gt;</span> ( ) , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCService</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCService</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCService</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCService</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">descriptor</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCService</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">descriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCService</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">invoke</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCService</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">invoke</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCService</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">destroy</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCService</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">destroy</span> ) ) ) ; } # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Service descriptor.&quot;</span> ] # [ <span class="ident">repr</span> ( <span class="ident">C</span> ) ] # [ <span class="ident">derive</span> ( <span class="ident">Debug</span> , <span class="ident">Copy</span> , <span class="ident">Clone</span> ) ] <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">ProtobufCServiceDescriptor</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Magic value checked to ensure that the API is used correctly.&quot;</span> ] <span class="kw">pub</span> <span class="ident">magic</span> : <span class="ident">u32</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Service name.&quot;</span> ] <span class="kw">pub</span> <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Short version of service name.&quot;</span> ] <span class="kw">pub</span> <span class="ident">short_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; C identifier for the service name.&quot;</span> ] <span class="kw">pub</span> <span class="ident">c_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Package name.&quot;</span> ] <span class="kw">pub</span> <span class="ident">package</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Number of elements in `methods`.&quot;</span> ] <span class="kw">pub</span> <span class="ident">n_methods</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Method descriptors, in the order defined in the .proto file.&quot;</span> ] <span class="kw">pub</span> <span class="ident">methods</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMethodDescriptor</span> , # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Sort index of methods.&quot;</span> ] <span class="kw">pub</span> <span class="ident">method_indices_by_name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , } # [ <span class="ident">test</span> ] <span class="kw">fn</span> <span class="ident">bindgen_test_layout_ProtobufCServiceDescriptor</span> ( ) { <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">size_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">64usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Size of: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( :: <span class="ident">std</span> :: <span class="ident">mem</span> :: <span class="ident">align_of</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Alignment of &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">magic</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">0usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">magic</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">8usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">short_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">16usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">short_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">c_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">24usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">c_name</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">package</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">32usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">package</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">n_methods</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">40usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">n_methods</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">methods</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">48usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">methods</span> ) ) ) ; <span class="ident">assert_eq</span> <span class="op">!</span> ( <span class="kw">unsafe</span> { <span class="op">&amp;</span> ( <span class="op">*</span> ( :: <span class="ident">std</span> :: <span class="ident">ptr</span> :: <span class="ident">null</span> :: <span class="op">&lt;</span> <span class="ident">ProtobufCServiceDescriptor</span> <span class="op">&gt;</span> ( ) ) ) . <span class="ident">method_indices_by_name</span> <span class="kw">as</span> <span class="op">*</span> <span class="kw">const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="ident">usize</span> } , <span class="number">56usize</span> , <span class="ident">concat</span> <span class="op">!</span> ( <span class="string">&quot;Offset of field: &quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">ProtobufCServiceDescriptor</span> ) , <span class="string">&quot;::&quot;</span> , <span class="ident">stringify</span> <span class="op">!</span> ( <span class="ident">method_indices_by_name</span> ) ) ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Get the version of the protobuf-c library. Note that this is the version of&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; the library linked against, not the version of the headers compiled against.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return A string containing the version number of protobuf-c.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_version</span> ( ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Get the version of the protobuf-c library. Note that this is the version of&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; the library linked against, not the version of the headers compiled against.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return A 32 bit unsigned integer containing the version number of&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      protobuf-c, represented in base-10 as (MAJOR*1E6) + (MINOR*1E3) + PATCH.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_version_number</span> ( ) <span class="op">-&gt;</span> <span class="ident">u32</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Look up a `ProtobufCEnumValue` from a `ProtobufCEnumDescriptor` by name.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param desc&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The `ProtobufCEnumDescriptor` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param name&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The `name` field from the corresponding `ProtobufCEnumValue` object to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      match.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      A `ProtobufCEnumValue` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\retval NULL&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      If not found.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_enum_descriptor_get_value_by_name</span> ( <span class="ident">desc</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCEnumDescriptor</span> , <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCEnumValue</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Look up a `ProtobufCEnumValue` from a `ProtobufCEnumDescriptor` by numeric&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; value.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param desc&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The `ProtobufCEnumDescriptor` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param value&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The `value` field from the corresponding `ProtobufCEnumValue` object to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      match.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      A `ProtobufCEnumValue` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\retval NULL&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      If not found.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_enum_descriptor_get_value</span> ( <span class="ident">desc</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCEnumDescriptor</span> , <span class="ident">value</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_int</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCEnumValue</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Look up a `ProtobufCFieldDescriptor` from a `ProtobufCMessageDescriptor` by&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; the name of the field.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param desc&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The `ProtobufCMessageDescriptor` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param name&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The name of the field.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      A `ProtobufCFieldDescriptor` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\retval NULL&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      If not found.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_descriptor_get_field_by_name</span> ( <span class="ident">desc</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessageDescriptor</span> , <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCFieldDescriptor</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Look up a `ProtobufCFieldDescriptor` from a `ProtobufCMessageDescriptor` by&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; the tag value of the field.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param desc&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The `ProtobufCMessageDescriptor` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param value&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The tag value of the field.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      A `ProtobufCFieldDescriptor` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\retval NULL&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      If not found.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_descriptor_get_field</span> ( <span class="ident">desc</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessageDescriptor</span> , <span class="ident">value</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCFieldDescriptor</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Determine the number of bytes required to store the serialised message.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param message&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The message object to serialise.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Number of bytes.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_get_packed_size</span> ( <span class="ident">message</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessage</span> ) <span class="op">-&gt;</span> <span class="ident">usize</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Serialise a message from its in-memory representation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function stores the serialised bytes of the message in a pre-allocated&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param message&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The message object to serialise.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param[out] out&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Buffer to store the bytes of the serialised message. This buffer must&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      have enough space to store the packed message. Use&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      protobuf_c_message_get_packed_size() to determine the number of bytes&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      required.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Number of bytes stored in `out`.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_pack</span> ( <span class="ident">message</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessage</span> , <span class="ident">out</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">u8</span> ) <span class="op">-&gt;</span> <span class="ident">usize</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Serialise a message from its in-memory representation to a virtual buffer.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function calls the `append` method of a `ProtobufCBuffer` object to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; consume the bytes generated by the serialiser.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param message&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The message object to serialise.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param buffer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The virtual buffer object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Number of bytes passed to the virtual buffer.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_pack_to_buffer</span> ( <span class="ident">message</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessage</span> , <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCBuffer</span> ) <span class="op">-&gt;</span> <span class="ident">usize</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Unpack a serialised message into an in-memory representation.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param descriptor&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The message descriptor.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param allocator&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      `ProtobufCAllocator` to use for memory allocation. May be NULL to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      specify the default allocator.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param len&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Length in bytes of the serialised message.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Pointer to the serialised message.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      An unpacked message object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\retval NULL&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      If an error occurred during unpacking.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_unpack</span> ( <span class="ident">descriptor</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessageDescriptor</span> , <span class="ident">allocator</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCAllocator</span> , <span class="ident">len</span> : <span class="ident">usize</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">u8</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCMessage</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Free an unpacked message object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; This function should be used to deallocate the memory used by a call to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; protobuf_c_message_unpack().&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param message&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The message object to free.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param allocator&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      `ProtobufCAllocator` to use for memory deallocation. May be NULL to&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      specify the default allocator.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_free_unpacked</span> ( <span class="ident">message</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCMessage</span> , <span class="ident">allocator</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCAllocator</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Check the validity of a message object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Makes sure all required fields (`PROTOBUF_C_LABEL_REQUIRED`) are present.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Recursively checks nested messages.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\retval TRUE&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Message is valid.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\retval FALSE&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Message is invalid.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_check</span> ( <span class="ident">arg1</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessage</span> ) <span class="op">-&gt;</span> <span class="ident">protobuf_c_boolean</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Initialise a message object from a message descriptor.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param descriptor&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Message descriptor.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param message&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Allocated block of memory of size `descriptor-&gt;sizeof_message`.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_message_init</span> ( <span class="ident">descriptor</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessageDescriptor</span> , <span class="ident">message</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Free a service.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param service&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The service object to free.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_service_destroy</span> ( <span class="ident">service</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCService</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; Look up a `ProtobufCMethodDescriptor` by name.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param desc&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Service descriptor.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param name&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Name of the method.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\return&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      A `ProtobufCMethodDescriptor` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\retval NULL&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      If not found.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_service_descriptor_get_method_by_name</span> ( <span class="ident">desc</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCServiceDescriptor</span> , <span class="ident">name</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_char</span> ) <span class="op">-&gt;</span> <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMethodDescriptor</span> ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; The `append` method for `ProtobufCBufferSimple`.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param buffer&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      The buffer object to append to. Must actually be a&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      `ProtobufCBufferSimple` object.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param len&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Number of bytes in `data`.&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot; \\param data&quot;</span> ] # [ <span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;      Data to append.&quot;</span> ] <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_buffer_simple_append</span> ( <span class="ident">buffer</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCBuffer</span> , <span class="ident">len</span> : <span class="ident">usize</span> , <span class="ident">data</span> : <span class="op">*</span> <span class="kw">const</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uchar</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_service_generated_init</span> ( <span class="ident">service</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCService</span> , <span class="ident">descriptor</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCServiceDescriptor</span> , <span class="ident">destroy</span> : <span class="ident">ProtobufCServiceDestroy</span> ) ; } <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> { <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">protobuf_c_service_invoke_internal</span> ( <span class="ident">service</span> : <span class="op">*</span> <span class="kw-2">mut</span> <span class="ident">ProtobufCService</span> , <span class="ident">method_index</span> : :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_uint</span> , <span class="ident">input</span> : <span class="op">*</span> <span class="kw">const</span> <span class="ident">ProtobufCMessage</span> , <span class="ident">closure</span> : <span class="ident">ProtobufCClosure</span> , <span class="ident">closure_data</span> : <span class="op">*</span> <span class="kw-2">mut</span> :: <span class="ident">std</span> :: <span class="ident">os</span> :: <span class="ident">raw</span> :: <span class="ident">c_void</span> ) ; }</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../../../../../../../../../../../";window.currentCrate = "libsignal_protocol_sys";</script><script src="../../../../../../../../../../../../aliases.js"></script><script src="../../../../../../../../../../../../main.js"></script><script src="../../../../../../../../../../../../source-script.js"></script><script src="../../../../../../../../../../../../source-files.js"></script><script defer src="../../../../../../../../../../../../search-index.js"></script></body></html>